blueprint:
  name: Frigate Light Trigger (0.0.0.1)
  author: SgtBatten
  homeassistant:
    min_version: 2024.11.0
  description: |
    ## Frigate Light Trigger

    A highly customizable automation blueprint for triggering lights based on Frigate events.
  domain: automation
  input:
    camera:
      name: Frigate Cameras
      description: |
        Select the cameras that will trigger notifications. 
        If you do not see cameras listed in the drop-down, check you have the Frigate integration installed.
        To more effectively customise the notifications you may need to create one automation per camera.
      selector:
        entity:
          filter:
            integration: frigate
            domain: camera
          multiple: true
    light:
      name: Light to Control
      description: The light entity to turn on when a Frigate event is triggered.
      selector:
        entity:
          domain: light
    mqtt_topic:
      name: MQTT Topic (Advanced)
      description: The MQTT topic Frigate sends review messages in.
      default: frigate/reviews
    filters:
      name: |
        # Filters
      description: These help limit when or what you are notified about.
      icon: mdi:filter
      collapsed: true
      input:
        review_severity:
          name: Event Type
          description: |
            Specify the classification of Frigate events to be notified about.
          default:
            - alert
            - detection
          selector:
            select:
              options:
                - label: Alerts
                  value: alert
                - label: Detections
                  value: detection
              multiple: true
        master_condition:
          name: Master Condition (Optional)
          description: Set conditions that will stop the automation from running if the result is false. No other tests will be conducted later. This is a kill switch on initiation.
          default: []
          selector:
            condition: {}
        zone_filter:
          name: Zone Filter on/off (Optional)
          description: Enable to only notify if an object has entered a zone listed below.
          default: false
          selector:
            boolean:
        zones:
          name: Required Zones (Optional - Enabled Above)
          description: |
            Enter the name of one zone at a time. It must be lowercase and include underscores as per your Frigate config.
            By default any zone is acceptable. If you desire ALL listed zones to be entered before getting a notification, enable the multi toggle below.
          default: []
          selector:
            select:
              options:
                - examples
                - porch
                - front_door
                - side
                - garden
              multiple: true
              custom_value: true
        zone_multi:
          name: Multi-Zone (Optional)
          description: Require all zones specified above to be entered, instead of any listed zone. Zone Filter must be enabled also.
          default: false
          selector:
            boolean:
        zone_order_enforced:
          name: Zone Order Enforced (Optional)
          description: |
            Combined with Multi-Zone, requires zones to be entered in the same order as their requirement. 
            Useful for alerting on arriving vehicles, while ignoring departing vehicles, for instance
          default: false
          selector:
            boolean:
        labels:
          name: Object Filter (Optional)
          description: Specify objects you wish to be notified about. Enter or select one object at a time.
          default: ""
          selector:
            select:
              options:
                - person
                - dog
                - cat
                - car
                - package
                - bird
              multiple: true
              custom_value: true
        presence_filter:
          name: Presence Filter (Optional)
          description: Only notify if ALL of the selected presence entities are not "home".
          default: ""
          selector:
            entity:
              filter:
                domain:
                  - device_tracker
                  - person
                  - group
              multiple: true
        state_filter:
          name: State Filter on/off (Optional)
          description: Enable the two State Filter settings below. Only notify if the selected entity is in the specified states.
          default: false
          selector:
            boolean:
        state_entity:
          name: State Filter Entity (Optional)
          description: Only notify if the selected entity is in the below state. You must enable "State Filter" above to use this.
          default: ""
          selector:
            entity:
        state_filter_states:
          name: State Filter States (Optional)
          description: Enter the states that the above entity must be in, one at a time.
          default: []
          selector:
            select:
              options: []
              multiple: true
              custom_value: true
        disable_times:
          name: Time Filter (Optional)
          description: Prevent notifications from being sent during the specified hours
          default: []
          selector:
            select:
              multiple: true
              options:
                - label: 00:00 - 00:59
                  value: "0"
                - label: 01:00 - 01:59
                  value: "1"
                - label: 02:00 - 02:59
                  value: "2"
                - label: 03:00 - 03:59
                  value: "3"
                - label: 04:00 - 04:59
                  value: "4"
                - label: 05:00 - 05:59
                  value: "5"
                - label: 06:00 - 06:59
                  value: "6"
                - label: 07:00 - 07:59
                  value: "7"
                - label: 08:00 - 08:59
                  value: "8"
                - label: 09:00 - 09:59
                  value: "9"
                - label: 10:00 - 10:59
                  value: "10"
                - label: 11:00 - 11:59
                  value: "11"
                - label: 12:00 - 12:59
                  value: "12"
                - label: 13:00 - 13:59
                  value: "13"
                - label: 14:00 - 14:59
                  value: "14"
                - label: 15:00 - 15:59
                  value: "15"
                - label: 16:00 - 16:59
                  value: "16"
                - label: 17:00 - 17:59
                  value: "17"
                - label: 18:00 - 18:59
                  value: "18"
                - label: 19:00 - 19:59
                  value: "19"
                - label: 20:00 - 20:59
                  value: "20"
                - label: 21:00 - 21:59
                  value: "21"
                - label: 22:00 - 22:59
                  value: "22"
                - label: 23:00 - 23:59
                  value: "23"
        custom_filter:
          name: Custom Filter (Optional - Advanced)
          description: A filter that must result in true or false but can be templated as necessary. You will need to ensure it is enclosed with appropriate \"quotes\" and \{\{brackets\}\}.
          default: true
    timers:
      name: |
        # Timers
      description: These are Timers you can customise
      icon: mdi:gesture-double-tap
      collapsed: true
      input:
        cooldown:
          name: Cooldown (Optional)
          description: Delay before sending another notification for this camera after the last event.
          default: 0
          selector:
            number:
              max: 86400
              min: 0
              unit_of_measurement: seconds
        timeout:
          name: Timeout
          description: Length of time the automation will wait for MQTT updates.
          default: 2
          selector:
            number:
              max: 90
              min: 0
              unit_of_measurement: minutes
        silence_timer:
          name: Silence New Notifications (Optional)
          description: |
            How long to pause notifications for this camera when requested as part of the actionable notification. 
            Note: Restarting Home Assistant during the period will break the timer and may disable the automation
          default: 30
          selector:
            number:
              max: 3600
              min: 0
              unit_of_measurement: minutes
        loiter_timer:
          name: Loitering Notifications (Optional)
          description: >
            Sends new loitering notification if a stationary object is detected for longer
            than the specified time. 0 is off and will not send notifications.
          default: 0
          selector:
            number:
              max: 3600
              min: 0
              unit_of_measurement: seconds
        initial_delay:
          name: Delay initial notification (Optional)
          description: |
            How long to delay the first notification for each event. Only applies if all conditions are met when the first event is defined by frigate

            Use this if you DO NOT use "update image" and are experiencing notifications without attached images. Start with small numbers.
          default: 0
          selector:
            number:
              max: 15
              min: 0
              unit_of_measurement: seconds
        final_delay:
          name: Delay Final notification (Optional)
          description: |
            How long to delay the final notification for each event. Only applies if Final Update is enabled.
          default: 5
          selector:
            number:
              max: 20
              min: 0
              unit_of_measurement: seconds
    debug:
      name: |
        # DEBUG
      description: These are DEBUG Options
      icon: mdi:bug
      collapsed: true
      input:
        debug:
          name: Debug
          description: Enable to send debug messages to the home assistant logbook.
          default: false
          selector:
            boolean:
        redacted:
          name: Redact Base URL
          description: Hides the Base URL in the debug output for easier sharing. Does not hide it from other parts of the trace.
          default: true
          selector:
            boolean:
mode: parallel
trigger_variables:
  # severity: !input review_severity
  mqtt_topic: !input mqtt_topic
triggers:
  - trigger: mqtt
    topic: "{{mqtt_topic}}"
    payload: "new"
    value_template: "{{value_json['type']}}"
    id: frigate-event
variables:
  input_camera: !input camera
  input_camera_name: "{{input_camera|expand|map(attribute='attributes.camera_name', default='none')|list}}"
  camera: "{{trigger.payload_json['after']['camera'] if trigger.id == 'frigate-event'}}"
  camera_name: "{{ camera | replace('_', ' ') | title }}"
  input_severity: !input review_severity
  severity: "{{trigger.payload_json['after']['severity'] if trigger.id == 'frigate-event'}}"
  type: "{{trigger.payload_json['type'] if trigger.id == 'frigate-event'}}"
  update_sub_label: !input update_sub_label
  input_client_id: !input client_id
  client_id: "{{input_client_id if not input_client_id else '/' + input_client_id if '/' not in input_client_id else input_client_id }}"
  final_update: true
  zone_only: !input zone_filter
  input_zones: !input zones
  zones: "{{ input_zones }}"
  zone_multi: !input zone_multi
  zone_order_enforced: !input zone_order_enforced
  input_labels: !input labels
  labels: "{{ input_labels | list | lower }}"
  presence_entity: !input presence_filter
  disable_times: !input disable_times
  cooldown: !input cooldown
  timeout: !input timeout
  loitering: false
  loiter_timer: !input loiter_timer
  initial_delay: !input initial_delay
  final_delay: !input final_delay
  fps: "{{ states('sensor.' + camera + '_camera_fps')|int(5) }}"
  state_only: !input state_filter
  input_entity: !input state_entity
  input_states: !input state_filter_states
  states_filter: "{{ input_states | list | lower }}"
  custom_filter: !input custom_filter
  sticky: !input sticky
  debug: !input debug
  redacted: !input redacted
  master_condition: !input master_condition
  # Dynamic Variables per event
  severity_satisfied: "{{input_severity|select('in', severity)|list|length > 0 if trigger.id == 'frigate-event'}}"
  objects: "{{ trigger.payload_json['after']['data']['objects'] if trigger.id == 'frigate-event' }}"
  objects_satisfied: "{{ not labels|length or labels|select('in', objects)|list|length > 0 or ('person-verified' in objects and 'person' in labels) }}"
  initial_home: "{{ presence_entity != '' and presence_entity|expand|selectattr('state','eq','home')|list|length != 0 }}"
  state_satisfied: "{{ not state_only or states(input_entity)|lower in states_filter }}"
  before_zones: "{{ trigger.payload_json['before']['data']['zones'] if trigger.id == 'frigate-event' }}"
  after_zones: "{{ trigger.payload_json['after']['data']['zones'] if trigger.id == 'frigate-event' }}"
  zone_multi_filter: "{{zone_only and zone_multi and after_zones|length and zones and zones |reject('in', after_zones) |list |length == 0 }}"
conditions:
  condition: or
  conditions:
    - condition: trigger
      id: silence
    - condition: trigger
      id: custom
    - condition: and
      conditions:
        - condition: trigger
          id: frigate-event
        - alias: Camera Match
          condition: template
          value_template: "{{ input_camera_name|select('equalto', camera)|list|length>0 }}"
        - alias: Master Condition
          condition: !input master_condition
        - alias: Cooldown
          condition: template
          value_template: "{{ not this.attributes.last_triggered or (now() - this.attributes.last_triggered).seconds > cooldown }}"
        - alias: Disable Times
          condition: template
          value_template: "{{ not disable_times|length or not now().hour in disable_times|map('int')|list }}"
actions:
  - choose:
      - alias: "Silence New Object Notifications"
        conditions:
          - condition: trigger
            id: silence
        sequence:
          - action: automation.turn_off
            target:
              entity_id: "{{ this.entity_id }}"
            data:
              stop_actions: false
          - delay:
              minutes: !input silence_timer
          - action: automation.turn_on
            target:
              entity_id: "{{ this.entity_id }}"
      - alias: "Custom Action Manual"
        conditions:
          - condition: trigger
            id: custom
        sequence: !input "custom_action_manual"
      - alias: "Frigate Event"
        conditions:
          - condition: trigger
            id: "frigate-event"
        sequence:
          - variables:
              event: "{{ trigger.payload_json }}"
              detections: "{{ event['after']['data']['detections'] }}"
              review_id: "{{event['after']['id']}}"
              id: "{{ detections[0] }}"
              objects: "{{ event['after']['data']['objects'] }}"
              sub_labels: "{{ event['after']['data']['sub_labels'] }}"
              label: >-
                {% if update_sub_label %}
                  {% set data = namespace(labels=[]) %} 
                  {% if labels|length %}
                    {% for obj in objects|select('in', labels) %}
                      {% if "-verified" in obj %}
                      {% else %}
                        {% set data.labels = data.labels + [obj] %}
                      {% endif %}
                    {% endfor %} {% set data.labels = data.labels + sub_labels %} 
                    {{ data.labels | unique | list | sort | join(", ") | title }}
                  {% else %}
                    {% for obj in objects %}
                      {% if "-verified" in obj %}
                      {% else %}
                        {% set data.labels = data.labels + [obj] %}
                      {% endif %}
                    {% endfor %} {% set data.labels = data.labels + sub_labels %} 
                    {{ data.labels | unique | list | sort | join(", ") | title }}
                  {% endif %}
                {% else %}
                  {{ objects | list | join(", ") | title }}
                {% endif %}

              # Dynamic Variables per event
              # after_zones: "{{ event['after']['data']['zones'] }}"
              # zone_multi_filter: "{{zone_only and zone_multi and after_zones|length and zones and zones |reject('in', after_zones) |list |length == 0 }}"

              # Zones Variables
              # If no zones defined, or any zones have been entered
              any_zones_entered: "{{ zones | length == 0 or ((zones | select('in', after_zones) | list | length) > 0) }}"
              zone_single_satisfied: "{{ any_zones_entered if zone_only else true}}"

              # If no zones defined, or all zones have been entered
              all_zones_entered: "{{ zones | length == 0 or ((zones | reject('in', after_zones) | list | length) == 0) }}"
              zone_multi_satisfied: "{{ all_zones_entered if zone_only and zone_multi else true}}"

              # Compare the joined strings for equality is the simplest solution, due to both variables being defined in band.
              ordered_zones_match: >
                {% set ns = namespace(intersection=[]) %}
                {% for item in after_zones %}
                    {% if item in zones %}
                        {% set ns.intersection = ns.intersection + [item] %}
                    {% endif %}
                {% endfor %}
                {{ ns.intersection == zones }}
              # Fails fast if prerequisite of zone or zone_multi is false, as they are pre-requisites
              zone_order_satisfied: "{{ (zone_only and zone_multi and ordered_zones_match) if zone_order_enforced else true }}"

              zones_satisfied: "{{zone_single_satisfied and zone_multi_satisfied and zone_order_satisfied}}"
          - alias: "Debug: Initial Output"
            choose:
              - conditions:
                  - "{{debug}}"
                sequence:
                  - action: logbook.log
                    data_template:
                      name: Frigate Notification
                      message: |
                        DEBUG: 
                          Info:
                            FPS: {{fps}}, 
                            Frigate Review id: {{review_id}}{{', Frigate client ID: ' + client_id if client_id else ''}}, 
                            Frigate Detections: {{detections}}
                            Objects: {{label}},
                            Sub Labels: {{sub_labels | join(', ')}}
                          Config: 
                            Camera(formatted): {{camera}}({{camera_name}}),
                            Critical: {{critical}}, 
                            TTS: {{tts}} 
                            TTS Helper: {{tts_helper if tts else 'N/A'}},
                            Final_Update (delay): {{final_update}} ({{final_delay}})s, 
                            Cooldown: {{cooldown}}s, 
                            Initial Delay: {{initial_delay}}s, 
                            Tag: {{ id }}, 
                            Group: {{group}}, 
                            Channel: {{channel}} {{' - overridden by alarm_stream' if critical}}, 
                          Filters: 
                            Severity:
                              Required Severity: {{input_severity}},
                              TEST: {{'PASS' if severity_satisfied else 'FAIL'}} - {{severity}}
                            Zones: 
                              Zone Filter toggle on: {{zone_only}}, 
                              Multi-Zone toggle on: {{zone_multi}}, 
                              Required zones: {{input_zones}}, 
                              Zone Order toggle on: {{zone_order_enforced}}
                              Entered Zones: {{after_zones}},
                              TEST: {{'PASS' if zones_satisfied else 'FAIL' }} {{'(Multi)' if zone_only and zone_multi}} {{'(Order-Enforced)' if zone_only and zone_multi and zone_order_enforced}}, 
                            Required objects: 
                              Input: {{input_labels}}, 
                              TEST: {{'PASS' if objects_satisfied else 'FAIL'}} - {{objects}}
                            presence entity (not home):
                              Entity: {{presence_entity}}
                              TEST:  {{'PASS' if not initial_home else 'FAIL'}}, 
                            disabled times: {{disable_times}}, 
                            State Filter: 
                              State Filter toggle on: {{state_only}}, 
                              State Filter Entity: {{input_entity}}, 
                              Required States: {{input_states}}, 
                              TEST: {{'PASS' if state_satisfied else 'FAIL' }},
                            Custom Filter: {{custom_filter}}
          - choose:
              - conditions:
                  - alias: Severity Filter
                    condition: template
                    value_template: "{{ severity_satisfied }}"
                  - alias: "Object Filter"
                    condition: template
                    value_template: "{{ objects_satisfied }}"
                  - alias: Zone Filter
                    condition: template
                    value_template: "{{ zones_satisfied }}"
                  - alias: Presence Filter
                    condition: template
                    value_template: "{{ not initial_home }}"
                  - alias: State Filter
                    condition: template
                    value_template: "{{ state_satisfied }}"
                  - alias: Custom Filter
                    condition: template
                    value_template: "{{ custom_filter }}"
                sequence:
                  - alias: "Delay for image"
                    choose:
                      - conditions: "{{initial_delay > 0}}"
                        sequence:
                          - delay:
                              seconds: "{{initial_delay}}"
                  - alias: "Trigger Light"
                    sequence:
                      - action: light.turn_on
                        target:
                          entity_id: !input "light"
                        data:
                          brightness_pct: 80
                      - if: "{{tts and (not tts_helper or (tts_helper and id not in states(tts_helper)))}}"
                        then:
                          sequence:
                            - action: input_text.set_value
                              data:
                                value: |
                                  {% set newIds = id + '|' + states(tts_helper) %}
                                  {{ newIds[:250] }}
                              target:
                                entity_id: "{{tts_helper}}"
          ########################################################
          #################### LOOP for updates ##################
          ########################################################
          - repeat:
              sequence:
                - wait_for_trigger:
                    - trigger: mqtt
                      topic: "{{mqtt_topic}}"
                      payload: "{{ review_id }}"
                      value_template: "{{ value_json['after']['id'] }}"
                  timeout:
                    minutes: "{{timeout}}"
                  continue_on_timeout: false
                - variables:
                    event: "{{ wait.trigger.payload_json }}"
                    type: "{{event['type']}}"

                    initial_severity: "{{severity}}"
                    old_objects: "{{objects}}"
                    last_zones: "{{after_zones}}"
                    # Sometimes mqtt messages are missed so we keep the previous iteration severity, objects and zones to compare against the new ones,
                    # rather than comparing the new before and after which may match despite a change between mqtt messages

                    severity: "{{event['after']['severity']}}"
                    severity_updated: "{{initial_severity != severity}}"
                    severity_satisfied: "{{((input_severity | select('equalto', severity) | list | length) > 0) }}"

                    objects: "{{ event['after']['data']['objects'] }}"
                    objects_satisfied: "{{ not labels|length or labels|select('in', objects)|list|length > 0 or ('person-verified' in objects and 'person' in labels) }}"
                    #loitering: "{{ loiter_timer and event['before']['motionless_count']/fps/60 < loiter_timer and event['after']['motionless_count']/fps/60 >= loiter_timer }}"
                    home: "{{presence_entity |reject('in', '') |select('is_state', 'home') |list |length != 0 }}"
                    #new_snapshot: "{{ update_thumbnail and event['before']['snapshot']['frame_time'] != event['after']['snapshot']['frame_time'] }}"
                    presence_changed: "{{ presence_entity |reject('in', '') |expand |map(attribute='last_changed') |list |select('gt', as_datetime(event['before']['start_time'])) |list |length != 0 }}"

                    # Zones Variables

                    before_zones: "{{ event['before']['data']['zones'] | default([]) }}"
                    after_zones: "{{ event['after']['data']['zones'] | default([]) }}"
                    # If no zones defined, or any zones have been entered
                    any_zones_entered: "{{ zones | length == 0 or ((zones | select('in', after_zones) | list | length) > 0) }}"
                    zone_single_satisfied: "{{ any_zones_entered if zone_only else true}}"

                    # If no zones defined, or all zones have been entered
                    all_zones_entered: "{{ zones | length == 0 or ((zones | reject('in', after_zones) | list | length) == 0) }}"
                    zone_multi_satisfied: "{{ all_zones_entered if zone_only and zone_multi else true}}"

                    # Compare the joined strings for equality is the simplest solution, due to both variables being defined in band.
                    ordered_zones_match: >
                      {% set ns = namespace(intersection=[]) %}
                      {% for item in after_zones %}
                          {% if item in zones %}
                              {% set ns.intersection = ns.intersection + [item] %}
                          {% endif %}
                      {% endfor %}
                      {{ ns.intersection == zones }}
                    # Fails fast if prerequisite of zone or zone_multi is false, as they are pre-requisites
                    zone_order_satisfied: "{{ (zone_only and zone_multi and ordered_zones_match) if zone_order_enforced else true }}"

                    zones_satisfied: "{{zone_single_satisfied and zone_multi_satisfied and zone_order_satisfied}}"

                    new_entered_zones: "{{ zones | select('in', after_zones) | list }}"
                    last_entered_zones: "{{ zones | select('in', last_zones) | list }}"
                    entered_new_zones: "{{ not zone_only and after_zones | length > last_zones | length }}"
                    entered_new_filter_zones: "{{ zone_only and zones | length > 0 and (new_entered_zones | length > last_entered_zones | length) }}"

                    # stationary_moved: "{{ event['after']['position_changes'] > event['before']['position_changes'] }}"

                    state_satisfied: "{{ not state_only or states(input_entity)|lower in states_filter }}"

                    before_sub_labels: "{{ sub_labels }}"
                    sub_labels: "{{ event['after']['data']['sub_labels'] | default([]) }}"
                    # assess the sub labels from the mqtt message.
                    # If the user has configured specific objects we eliminate objects not in that list
                    # Otherwise we loop through all objects and replace any verified objects with the sub label
                    label: >-
                      {% if update_sub_label %}
                        {% set data = namespace(labels=[]) %} 
                        {% if labels|length %}
                          {% for obj in objects|select('in', labels) %}
                            {% if "-verified" in obj %}
                            {% else %}
                              {% set data.labels = data.labels + [obj] %}
                            {% endif %}
                          {% endfor %} {% set data.labels = data.labels + sub_labels %} 
                          {{ data.labels | unique | list | sort | join(", ") | title }}
                        {% else %}
                          {% for obj in objects %}
                            {% if "-verified" in obj %}
                            {% else %}
                              {% set data.labels = data.labels + [obj] %}
                            {% endif %}
                          {% endfor %} {% set data.labels = data.labels + sub_labels %} 
                          {{ data.labels | unique | list | sort | join(", ") | title }}
                        {% endif %}
                      {% else %}
                        {{objects | list | join(', ') | title}}
                      {% endif %}
                    # import the title and message again so any sublabel, object or zone changes are captured.
                    tts: !input tts

                    sub_label_updated: "{{ update_sub_label and sub_labels != before_sub_labels }}"
                    # If we are filtering based on zones, and zone conditions are met and there is a new zone added.
                    zone_updated: "{{ (entered_new_filter_zones and zones_satisfied) or entered_new_zones }}"
                    object_updated: "{{ old_objects | select('in', labels) | list | length  != objects | select('in', labels) | list | length }}"

                - alias: "Debug: Loop Output"
                  choose:
                    - conditions:
                        - "{{debug}}"
                      sequence:
                        - action: logbook.log
                          data_template:
                            name: Frigate Notification
                            message: |
                              DEBUG (in loop):
                                Send Notification: {{custom_filter and not home and zones_satisfied and state_satisfied and objects_satisfied and severity_satisfied and ((final_update and type == 'end') or (severity_updated or presence_changed or zone_updated or object_updated or sub_label_updated)) }}
                                Triggers:
                                  New Snapshot: False (not functional with reviews)
                                  Severity Changed: {{severity_updated}},
                                  Presence Changed: {{presence_changed}},
                                  Object changed: {{object_updated}},
                                  Zones Changed: {{'True' if entered_new_filter_zones and zones_satisfied else 'True - zone filter disabled' if entered_new_zones and not zone_only else 'True - Filter Criteria not met' if entered_new_zones else 'False'}},
                                  Sublabel changed: {{ sub_label_updated }}{{' - Disabled' if not update_sub_label}},
                                  Final Update: {{final_update and type == 'end'}}
                                Conditions:
                                  Filters:
                                    Severity:
                                      Required Severity: {{input_severity}}
                                      TEST: {{'PASS' if severity_satisfied else 'FAIL'}} - {{severity}}, 
                                    Zones:
                                      Zone Filter toggle on: {{zone_only}},
                                      Multi-Zone toggle on: {{zone_multi}},
                                      Required zones: {{input_zones}},
                                      Zone Order toggle on: {{zone_order_enforced}}
                                      Last Zones: {{ last_zones | list | length }} - {{last_zones}},
                                      New Zones: {{ after_zones | list | length }} - {{after_zones}},
                                      TEST: {{'PASS' if zones_satisfied else 'FAIL' }} {{'(Multi)' if zone_only and zone_multi}} {{'(Order-Enforced)' if zone_only and zone_multi and zone_order_enforced}},
                                    Object Filter:
                                      Input: {{input_labels}},
                                      TEST: {{'PASS' if objects_satisfied else 'FAIL'}} - {{objects}},
                                    Presence entity (not home):
                                      Entity: {{presence_entity}},
                                      TEST:  {{'PASS' if not home else 'FAIL'}},
                                    Time Filter:
                                      Disabled times: {{disable_times}},
                                      TEST: {{'PASS' if now().hour not in disable_times else 'FAIL'}}
                                    State Filter:
                                      State Filter toggle on: {{state_only}},
                                      State Filter Entity: {{input_entity}},
                                      Required States: {{input_states}},
                                      TEST: {{'PASS' if state_satisfied else 'FAIL'}},
                                    Custom Filter: {{'PASS' if custom_filter else 'FAIL'}},
                - choose:
                    - conditions:
                        - and:
                            - alias: Severity Filter
                              condition: template
                              value_template: "{{severity_satisfied}}"
                            - alias: Object Filter
                              condition: template
                              value_template: "{{ objects_satisfied }}"
                            - alias: Zone Filter
                              condition: template
                              value_template: "{{zones_satisfied}}"
                            - alias: State Filter
                              condition: template
                              value_template: "{{state_satisfied}}"
                            - alias: Custom Filter
                              condition: template
                              value_template: "{{custom_filter}}"
                            - alias: Presence Filter
                              condition: template
                              value_template: "{{not home}}"
                            - or:
                                - alias: Presence Changed
                                  condition: template
                                  value_template: "{{presence_changed}}"
                                - alias: Zone Changed
                                  condition: template
                                  value_template: "{{zone_updated}}"
                                - alias: Sub Label Changed
                                  condition: template
                                  value_template: "{{sub_label_updated}}"
                                - alias: Object Changed
                                  condition: template
                                  value_template: "{{object_updated}}"
                                - alias: Severity Changed
                                  condition: template
                                  value_template: "{{severity_updated}}"
                                - and:
                                    - alias: Final Update
                                      condition: template
                                      value_template: "{{final_update}}"
                                    - alias: End of Event
                                      condition: template
                                      value_template: "{{event['type'] == 'end'}}"
                      sequence:
                        - alias: "Delay for Final Update"
                          choose:
                            - conditions:
                                - "{{ event['type'] == 'end' }}"
                                - "{{ final_update }}"
                              sequence:
                                - delay:
                                    seconds: "{{final_delay}}"
                        - alias: "Update Notification"
                          sequence:
                            - action: automation.trigger
                              data:
                                skip_condition: true
                              target:
                                entity_id: automation.turn_on_front_porch_at_sun_set
                            - if: "{{tts and (not tts_helper or (tts_helper and id not in states(tts_helper)))}}"
                              then:
                                sequence:
                                  - action: input_text.set_value
                                    data:
                                      value: |
                                        {% set newIds = id + '|' + states(tts_helper) %}
                                        {{ newIds[:250] }}
                                    target:
                                      entity_id: "{{tts_helper}}"
              until: "{{ not wait.trigger or wait.trigger.payload_json['type'] == 'end' }}"